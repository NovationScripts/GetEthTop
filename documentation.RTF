{\rtf1\ansi\deff0\nouicompat{\fonttbl{\f0\fnil\fcharset0 Calibri;}{\f1\fnil Calibri;}}
{\*\generator Riched20 10.0.19041}\viewkind4\uc1 
\pard\sa200\sl276\slmult1\f0\fs22\lang1033 // Data structure for a player\par
struct Player \{\par
    address referrer; // Address of the player who referred this player\par
    uint256 referralEarnings; // Amount earned by the player from referrals\par
    uint256 currentLevel; // Current level of the player in the game\par
    uint256 deposit; // Amount of ether deposited by the player\par
    bool isWaiting; // Indicates whether the player is waiting for a payout\par
    uint256 stepsCompleted;  // Number of steps completed by the player\par
    bool hasFinished; // Flag to track whether the player has finished the game\par
    uint256 referralWithdrawals; // Variable added to track the total amount of withdrawals made by referrals\par
    uint256 lastStepTime; // Timestamp of the player's last step\par
    uint256 referralsCompletedFirstLevel; // Number of referrals who have completed the first level\par
\}\par
This code snippet defines a Player struct in Solidity, representing the state and attributes of each player in the game. It includes details like the referrer's address, earnings from referrals, the current level in the game, deposited amount, completion status, and other relevant information.\par
\par
// Structure for a queue\par
struct Queue \{\par
    address[] queue; // Array of addresses in the queue\par
    uint256 front;   // Index of the front element in the queue\par
    uint256 back;    // Index of the back element in the queue\par
\}\par
\par
// Data structure for a level in the game\par
struct Level \{\par
    uint256 currentStep; // Current step within the level\par
    uint256 budget;      // Budget allocated for the level\par
    uint256 reward;      // Reward for completing the level\par
    Queue playersQueue;  // Queue of players in the level\par
\}\par
This code defines two structs in Solidity: Queue and Level. The Queue struct is a simple queue data structure with functionality for tracking the front and back positions. The Level struct represents each level in the game, including its current step, budget, reward, and a queue of players participating in that level.\par
\par
// Mapping of player addresses to their data\par
mapping(address => Player) public players; \par
\par
// Array representing data for each level in the game\par
Level[14] public levels; \par
\par
// Mapping to track total payouts for each player\par
mapping(address => uint256) public totalPayouts; \par
\par
// Events for logging actions in the contract\par
event Registered(address indexed player, uint256 deposit, uint256 level); // Triggered when a player registers\par
event LevelUp(address indexed player, uint256 newLevel); // Triggered when a player moves up a level\par
event ReceivedPayment(address indexed player, uint256 amount); // Triggered when a player receives a payment\par
event DonationMade(address indexed donor, uint256 amount); // Triggered when a donation is made\par
event OwnerWithdrawal(address indexed owner, uint256 withdrawalAmount, uint256 redistributedAmount); // Triggered when the owner withdraws funds\par
event ReferralWithdrawal(address indexed referrer, uint256 withdrawalAmount, uint256 redistributedAmount); // Triggered when a referrer withdraws funds\par
event ReferralWithdrawalMade(address indexed referrer, uint256 amount); // Triggered when a referrer successfully withdraws referral earnings\par
\par
This section defines a mapping to associate player addresses with their data, an array to store level data, and another mapping for tracking total payouts to each player. Additionally, it declares various events for logging different activities within the contract, like registration, level progression, payments, donations, and withdrawals. These events help in tracking the state and activities of the contract when emitted.\par
\par
// Function for registering a player\par
function register(address _referrer) external \{\par
    // Check to ensure the player is not already registered\par
    require(players[msg.sender].referrer == address(0), "Player already registered");\par
\par
    // Ensure the registration is not for the first time in the system\par
    require(msg.sender != owner, "Owner is already registered");\par
\par
    // Check for the presence of a valid referrer in the system who is not the current player\par
    require(_referrer != address(0) && _referrer != msg.sender && players[_referrer].referrer != address(0), "Invalid referrer");\par
\par
    // Register the player with the specified referrer\par
    players[msg.sender].referrer = _referrer;\par
\}\par
\par
This function allows a new player to register in the system. It ensures that the player is not already registered and that they are not the owner of the contract (since the owner is pre-registered). Additionally, it verifies the validity of the referrer \f1\endash  the referrer must be a registered player and cannot be the player themself. Upon successful validation, the function sets the player's referrer.\par
\par
// Function to get the total number of first deposits\par
function getTotalFirstDeposits() public view returns (uint256) \{\par
    return totalFirstDeposits;\par
\}\par
\par
// Function to check if a player can make the next step\par
function canMakeNextStep(address playerAddress) public view returns (bool) \{\par
    Player storage player = players[playerAddress];\par
    // Required waiting time is 2 hours minus 1 second for each successful referral\par
    uint256 requiredWait = 2 hours - player.referralsCompletedFirstLevel;\par
    // Check if the current time is greater than the player's last step time plus the required wait time\par
    return block.timestamp >= (player.lastStepTime + requiredWait);\par
\}\par
\par
This code snippet includes a function to retrieve the total number of first deposits made in the game. The second function checks if a player is eligible to make the next step in the game. It calculates the required waiting time based on the number of successful referrals completed by the player. If the current time surpasses the last step time of the player plus the calculated waiting time, the player is eligible to proceed to the next step.\par
\par
// Function for making a deposit\par
function makeDeposit(uint256 /* amount */) public payable onlyPlayer \{\par
    Player storage player = players[msg.sender];\par
    // Ensure the player is not in waiting mode\par
    require(!player.isWaiting, "Player is in waiting mode");\par
    // Check if the deposit amount matches the step cost for the player's current level\par
    require(msg.value == STEP_COSTS[player.currentLevel], "Incorrect deposit for the current level");\par
    \par
    // Calculate waiting time as 2 hours minus 1 second for each referral who completed the first level\par
    uint256 waitingTime = 2 hours - player.referralsCompletedFirstLevel * 1 seconds;\par
    // Ensure the current time is greater than the player's last step time plus waiting time\par
    require(block.timestamp >= player.lastStepTime + waitingTime, "You must wait to make the next step");\par
\par
    // Increment the counter for first deposits if the player is making a deposit at the first level\par
    if (players[msg.sender].currentLevel == 1 && players[msg.sender].deposit == 0) \{\par
        totalFirstDeposits += 1;\par
    \}\par
    \par
    // Update the time of the player's last step\par
    player.lastStepTime = block.timestamp;\par
\par
    // If the player is not on the first level, redistribute 1% to the first level's budget\par
    if(players[msg.sender].currentLevel > 1) \{\par
        uint256 redistributionAmount = msg.value / 100;\par
        levels[1].budget += redistributionAmount;\par
    \}\par
\par
    // Calculate the referral fee as 1% of the deposit amount\par
    uint256 referralFee = msg.value / 100;\par
    // Calculate the contract commission\par
    uint256 contractCommission = (msg.value * CONTRACT_COMMISSION) / 100;\par
    // Accumulate the contract earnings\par
    contractEarnings += contractCommission;  \par
\par
    // Increase the player's deposit amount\par
    player.deposit += msg.value;\par
\par
    // Calculate the reward from the deposit\par
    uint256 reward = (msg.value * REWARD_POOL) / 100;\par
    // Update the budget of the player's current level\par
    levels[player.currentLevel].budget += (msg.value - referralFee - contractCommission - reward);\par
    \par
    // Retrieve the player's referrer\par
    address referrer = player.referrer;\par
    // Ensure there is a referrer assigned to the player\par
    require(referrer != address(0), "No referrer assigned to player");\par
    \par
    // Accumulate the referral fee if the referrer has completed at least 10 steps on the first level\par
    if (players[referrer].currentLevel == 1 && players[referrer].stepsCompleted >= 10) \{\par
        // The referrer meets the condition, accrue referral rewards\par
        players[referrer].referralEarnings += referralFee;\par
    \}\par
\}\par
\par
This extended function includes additional logic for updating the player's last step time, redistributing funds to the budget of the first level if the player is beyond the first level, calculating and adding referral fees, contract commissions, and player rewards. It also ensures that the player's referrer (if any) receives their referral earnings under certain conditions.\par
\par
// Function to withdraw referral earnings\par
function withdrawReferralEarnings() external onlyPlayer \{\par
    Player storage player = players[msg.sender];\par
    uint256 amount = player.referralEarnings;\par
    // Ensure there are referral earnings to withdraw\par
    require(amount > 0, "No referral earnings to withdraw");\par
\par
    // Calculate the amount for redistribution and withdrawal\par
    uint256 redistributionAmount = amount / 10;\par
    uint256 withdrawalAmount = amount - redistributionAmount;\par
\par
    // Allocate 10% to the budget of the first level\par
    levels[1].budget += redistributionAmount;\par
\par
    // Record the withdrawal by the referee\par
    player.referralWithdrawals += withdrawalAmount;\par
    totalReferralWithdrawals += withdrawalAmount;\par
\par
    // Decrease the total referral earnings by the withdrawal amount\par
    totalReferralEarnings -= amount;\par
\par
    // Reset the player's referral earnings before sending funds\par
    player.referralEarnings = 0;\par
\par
    // Log the referral withdrawal event\par
    emit ReferralWithdrawalMade(msg.sender, withdrawalAmount);\par
\par
    // Send the remaining 90% to the referrer\par
    payable(msg.sender).transfer(withdrawalAmount);\par
\}\par
\par
This code describes a function for withdrawing a player's referral earnings. It checks if there are any earnings to withdraw, allocates a portion of these earnings to the budget of the first level, and sends the remaining 90% of the earnings to the player.\par
\par
// This function allows a player to play by making a step in the game.\par
function play() external payable onlyPlayer \{\par
    Player storage player = players[msg.sender];\par
    // If the player's level is 0, set it to the first level on the first step.\par
    if (player.currentLevel == 0) \{\par
        player.currentLevel = 1;\par
    \}\par
    // Add the sent value to the budget of the player's current level.\par
    levels[player.currentLevel].budget += msg.value;\par
    // Ensure the sent value matches the step cost for the current level.\par
    require(msg.value == STEP_COSTS[player.currentLevel], "Incorrect step cost sent");\par
\par
    // Increment the number of steps completed by the player.\par
    player.stepsCompleted++;\par
    \par
    // If the player has reached the maximum number of steps for their level,\par
    // move them to the next level.\par
    if (player.stepsCompleted >= LEVEL_STEPS[player.currentLevel]) \{\par
        moveToNextLevel(msg.sender);\par
    \}\par
\}\par
\par
\f0 This commentary explains the purpose of the function and the logic within it, step by step\par
\par
\par
// Function to check if a payout is available for a given player.\par
function isPayoutAvailableFor(address playerAddress) public view returns (bool) \{\par
    Player storage player = players[playerAddress];\par
    // Access the current level data of the player.\par
    Level storage currentLevel = levels[player.currentLevel];\par
    \par
    // Check if the player is in a waiting state and if the level's budget is sufficient \par
    // for a payout based on the player's deposit and the payout multiplier.\par
    if (player.isWaiting && currentLevel.budget >= player.deposit * PAYOUT_MULTIPLIER / 100) \{\par
        return true; // Payout is available.\par
    \}\par
    return false; // Payout is not available.\par
\}\par
\par
// Function for players to request their payout.\par
function requestPayout() external canRequestPayout \{\par
    // Process the payments for the player's current level.\par
    processPayments(players[msg.sender].currentLevel);\par
\}\par
\par
This explanation clarifies the role of each function: isPayoutAvailableFor to check payout availability and requestPayout to initiate the payout process.\par
\par
\par
// Function to process payments for a specific level.\par
function processPayments(uint256 level) internal onlyPlayer \{\par
    // Loop as long as the budget for the level is enough for the reward, and there are players in the queue.\par
    while (levels[level].budget >= levels[level].reward && levels[level].playersQueue.queue.length > 0) \{\par
        // Get the address of the first player in the queue and make it payable.\par
        address payable playerAddress = payable(levels[level].playersQueue.queue[levels[level].playersQueue.front]);\par
        // Retrieve the current player's data.\par
        Player storage currentPlayer = players[playerAddress];\par
        // Move to the next player in the queue.\par
        levels[level].playersQueue.front += 1;\par
\par
        // Calculate the payout based on the player's deposit and the payout multiplier.\par
        uint256 payout = currentPlayer.deposit * PAYOUT_MULTIPLIER / 100;\par
\par
        // Logic to redistribute 10% of the reward to the first level's budget if it's not the first level.\par
        if (currentPlayer.currentLevel > 1) \{\par
            uint256 rewardRedistribution = payout / 10;\par
            payout -= rewardRedistribution;\par
            levels[1].budget += rewardRedistribution;\par
            // An event for logging the redistribution could be added here if necessary.\par
        \}\par
\par
        // Check if the contract balance can cover the payout.\par
        if (address(this).balance >= payout) \{\par
            // Transfer the payout to the player.\par
            playerAddress.transfer(payout);\par
            // Record the total payout for the player.\par
            totalPayouts[playerAddress] += payout;\par
            // Emit an event for the received payment.\par
            emit ReceivedPayment(playerAddress, payout);\par
\par
            // Adjust the level's budget by subtracting the net payout (minus the original deposit).\par
            levels[level].budget -= (payout - currentPlayer.deposit);\par
            // Set the player's waiting status to false.\par
            currentPlayer.isWaiting = false;\par
\par
            // Move the player to the next level.\par
            moveToNextLevel(playerAddress);\par
        \} else \{\par
            // If the contract balance isn't sufficient for the payout, exit the loop.\par
            break;\par
        \}\par
    \}\par
\}\par
\par
This explanation provides a detailed walkthrough of the processPayments function, explaining each step in processing player payouts at a given level.\par
\par
// Function to move a player to the next level.\par
function moveToNextLevel(address playerAddress) internal \{\par
    // Retrieve player information from the storage.\par
    Player storage player = players[playerAddress];\par
    \par
    // Check if the player has reached the final level (14th).\par
    if (player.currentLevel == 14) \{\par
        // Mark the player as having finished the game.\par
        player.hasFinished = true;\par
        // Exit the function as the player has completed the game.\par
        return;\par
    \}\par
    \par
    // Increment the player's current level to move to the next level.\par
    player.currentLevel += 1;\par
    // Reset the number of steps completed and set the waiting status.\par
    player.stepsCompleted = 0;  \par
    player.isWaiting = true;\par
\par
    // Note: Levels start from 0, with 0 being the registration level.\par
    // Players begin at level 0 and can advance up to level 14.\par
    // Add the player to the queue of the next level.\par
    levels[player.currentLevel].playersQueue.queue[levels[player.currentLevel].playersQueue.back] = playerAddress;\par
    levels[player.currentLevel].playersQueue.back += 1;\par
    // Emit an event indicating the player has levelled up.\par
    emit LevelUp(playerAddress, player.currentLevel);\par
\par
    // Process payments for the next level, as the player moves up.\par
    processPayments(player.currentLevel);\par
\}\par
\par
This commentary explains the function moveToNextLevel, detailing each step of advancing a player to the next level in the game, including resetting their steps, updating their waiting status, and handling the player's position in the level queue.\par
\par
// Function to retrieve a player's referral earnings.\par
function getReferralEarnings() public view returns (uint256) \{\par
    // Returns the amount of referral earnings for the message sender.\par
    return players[msg.sender].referralEarnings;\par
\}\par
\par
// Function to get data of the current level of a player.\par
function getCurrentLevelData() external view returns(Level memory) \{\par
    // Retrieve player data from storage.\par
    Player storage player = players[msg.sender];\par
    // Check that the player's current level is valid (between 1 and 9).\par
    require(player.currentLevel > 0 && player.currentLevel <= 9, "Invalid level");\par
    // Return level data for the player's current level.\par
    return levels[player.currentLevel - 1];\par
\}\par
\par
// Function to get the count of players on a specified level.\par
function getPlayersCountOnLevel(uint256 _level) external view returns(uint256) \{\par
    // Ensure the specified level is valid (between 1 and 9).\par
    require(_level > 0 && _level <= 9, "Invalid level");\par
    // Return the length of the player queue for the specified level.\par
    return levels[_level - 1].playersQueue.queue.length;\par
\}\par
\par
// Function to get the list of players on a specified level.\par
function getPlayersOnLevel(uint256 _level) external view returns(address[] memory) \{\par
    // Ensure the specified level is valid (between 1 and 9).\par
    require(_level > 0 && _level <= 9, "Invalid level");\par
    // Return the addresses of players in the queue for the specified level.\par
    return levels[_level - 1].playersQueue.queue;\par
\}\par
\par
// Function to retrieve specific information about a player.\par
function getPlayerInfo(address _playerAddress) external view returns(uint256 level, uint256 stepsCompleted, bool hasFinished) \{\par
    // Retrieve player data from storage.\par
    Player storage player = players[_playerAddress];\par
    // Return the player's current level, steps completed, and finish status.\par
    return (player.currentLevel, player.stepsCompleted, player.hasFinished);\par
\}\par
\par
These comments explain the purpose and functionality of each function in your contract, focusing on retrieving information about players, their levels, and their progress within the game.\par
\par
\par
// Function to get the budgets of all levels.\par
function getBudgetsByLevel() public view returns (uint256[] memory) \{\par
    // Initialize an array to store the budgets of each level.\par
    uint256[] memory budgets = new uint256[](levels.length);\par
    // Iterate over each level and store its budget in the array.\par
    for (uint256 i = 0; i < levels.length; i++) \{\par
        budgets[i] = levels[i + 1].budget; // Offset by +1 as levels start from 1.\par
    \}\par
    // Return the array of budgets.\par
    return budgets;\par
\}\par
\par
// Function to get the contract commission percentage.\par
function getContractEarningsPercentage() public pure returns (uint256) \{\par
    // Return the constant value of the contract commission.\par
    return CONTRACT_COMMISSION;\par
\}\par
\par
// Function to get the total earnings of the contract.\par
function getTotalContractEarnings() public view returns (uint256) \{\par
    // Return the total earnings accumulated by the contract.\par
    return contractEarnings;\par
\}\par
\par
// Function to get the referral earnings percentage.\par
function getReferralEarningsPercentage() public pure returns (uint256) \{\par
    // Return the constant value of the referral commission.\par
    return REFERRAL_COMMISSION;\par
\}\par
\par
// Function to get the total referral earnings.\par
function getTotalReferralEarnings() public view returns (uint256) \{\par
    // Return the total amount of referral earnings.\par
    return totalReferralEarnings;\par
\}\par
\par
These comments provide clear explanations of the functions' purposes and operations within your smart contract, focusing on retrieving various financial metrics like budgets, earnings, and commission percentages.\par
\par
\par
// Function to get referral earnings by wallet address\par
function getReferralEarningsByWallet(address referrer) public view returns (uint256) \{\par
    // Return the referral earnings of the specified referrer address.\par
    return players[referrer].referralEarnings;\par
\}\par
\par
// Function to get referral withdrawals by wallet address\par
function getReferralWithdrawalsByWallet(address referrer) public view returns (uint256) \{\par
    // Return the total amount of referral withdrawals of the specified referrer address.\par
    return players[referrer].referralWithdrawals;\par
\}\par
\par
// Function to calculate the player's profit\par
function getPlayerProfit(address playerAddress) external view returns (int256) \{\par
    // Retrieve the player's data from the mapping\par
    Player storage player = players[playerAddress];\par
    \par
    // Calculate the difference between the total payouts to the player and their deposit\par
    int256 profit = int256(totalPayouts[playerAddress]) - int256(player.deposit);\par
\par
    // Return the calculated profit\par
    return profit;\par
\}\par
\par
// Function to withdraw contract earnings, accessible only by the contract owner\par
function withdrawEarnings() external onlyOwner \{\par
    // Store the total contract earnings in a local variable\par
    uint256 amount = contractEarnings;\par
    // Reset contract earnings to zero\par
    contractEarnings = 0;\par
    // Transfer the stored amount to the owner's address\par
    payable(owner).transfer(amount);\par
\}\par
\par
These comments provide a clear understanding of each function's purpose within your contract, such as retrieving referral earnings and withdrawals, calculating a player's profit, and enabling the owner to withdraw contract earnings.\par
\par
\par
// Function for donations to the first level\par
function donateToFirstLevel() public payable \{\par
    // Ensure the donated amount is greater than zero\par
    require(msg.value > 0, "Donation must be greater than 0");\par
    // Only allow players above level 1 to make a donation\par
    require(players[msg.sender].currentLevel > 1, "Only players above level 1 can donate");\par
\par
    // Add the donation amount to the budget of the first level\par
    // Index 1 is used because level numbering starts from 1\par
    levels[1].budget += msg.value;\par
    \par
    // Log the donation event\par
    emit DonationMade(msg.sender, msg.value);\par
\}\par
\par
// Function for the owner to withdraw earnings\par
function withdrawOwnerEarnings() external onlyOwner \{\par
    // Calculate 10% of the contract earnings for redistribution\par
    uint256 redistributionAmount = contractEarnings / 10;\par
    // Calculate the amount to be withdrawn by the owner\par
    uint256 withdrawalAmount = contractEarnings - redistributionAmount;\par
    \par
    // Distribute 10% to the budget of the first level\par
    levels[1].budget += redistributionAmount;\par
    \par
    // Reset contract earnings and transfer the withdrawal amount to the owner\par
    contractEarnings = 0;\par
    payable(owner).transfer(withdrawalAmount);\par
    \par
    // Log the event of owner's withdrawal and redistribution\par
    emit OwnerWithdrawal(owner, withdrawalAmount, redistributionAmount);\par
\}\par
\par
These comments explain the purpose and functionality of the donateToFirstLevel and withdrawOwnerEarnings functions in your smart contract. The former allows players above a certain level to make donations to the first level's budget, while the latter enables the owner to withdraw their earnings, redistributing a portion back into the game.\par
\par
// Modifier to ensure that only the contract owner can call certain functions\par
modifier onlyOwner() \{\par
    // Check that the message sender is the owner of the contract\par
    require(msg.sender == owner, "Caller is not the owner");\par
    _; // Continue execution of the function\par
\}\par
\par
// Modifier to ensure that only registered players can call certain functions\par
modifier onlyPlayer() \{\par
    // Check that the message sender is a registered player and has not finished the game\par
    require(players[msg.sender].referrer != address(0), "Not a registered player");\par
    require(!players[msg.sender].hasFinished, "Player has finished the game");\par
    _; // Continue execution of the function\par
\}\par
\par
// Internal function to complete the first level for a referrer\par
function completeFirstLevel(address referrer) internal \{\par
    // Increment the count of referrals who have completed the first level for the referrer\par
    players[referrer].referralsCompletedFirstLevel += 1;\par
\}\par
\par
// Modifier to check if a payout is available for the calling player\par
modifier canRequestPayout() \{\par
    // Check if the player is eligible for a payout\par
    require(isPayoutAvailableFor(msg.sender), "Payout is not available");\par
    _; // Continue execution of the function\par
\}\par
\par
These comments describe the functionality of the onlyOwner, onlyPlayer, and canRequestPayout modifiers, as well as the completeFirstLevel function. The onlyOwner modifier restricts certain functions to the contract owner, onlyPlayer ensures that only registered players who haven't finished the game can access certain features, and canRequestPayout checks the player's eligibility for a payout. The completeFirstLevel function is used to update referral achievements for players who have referred others.\par
\par
\par
\par
\par
}
 